#!/usr/bin/env ruby
# encoding: UTF-8

# Global todo items:
# XXX: I need to find a good guideline when to place parentheses.
#      Sometimes omitting them increases readability. Sometimes it
#      doesn't.
# XXX: Better inline documentation.

require 'date'
require 'fileutils'
require 'pathname'

module Colors
	@table = {
		:dead      => "\e[1;31m",
		:close     => "\e[31m",
		:very_high => "\e[1;31m",
		:high      => "\e[33m",
		:low       => "\e[34m",
		:very_low  => "\e[32m",
		:header    => "\e[1m",
		:reset     => "\e[0m",
	}

	def Colors.[](which)
		if !STDOUT.tty? && !ENV['GITODO_FORCE_COLOR']
			return ''
		else
			return @table[which]
		end
	end
end

class Item
	include Comparable

	attr_accessor :id
	attr_accessor :filename
	attr_accessor :prio
	attr_accessor :when
	attr_accessor :warn
	attr_accessor :what
	attr_accessor :nocron
	attr_accessor :content
	attr_accessor :timetype

	def initialize
		@id = 0
		@filename = ''
		@prio = 0
		@when = Time.local(2037)
		@warn = 1
		@what = ''
		@nocron = false
		@content = ''
		@timetype = :none
	end

	# "Formatted" id.
	def id_fmt
		'[%4s]' % @id.to_s
	end

	# Check if this item is okay, close to the deadline or dead.
	def classify
		now = Time.now
		if now > @when
			return :dead
		elsif now > @when - @warn * 3600
			return :close
		else
			return :normal
		end
	end

	# timetype as a number. Required for compatibility with legacy
	# "gitodo --raw".
	def timetype_num
		case @timetype
		when :time
			0
		when :date
			1
		when :datetime
			2
		else
			3
		end
	end

	# Hide unimportant items?
	def hide?
		classify == :normal && @prio > 99 && !ENV['GITODO_SHOW_UNIMPORTANT']
	end

	# Show a line suitable for output in the traditional listing.
	def show_brief
		case classify
		when :dead
			print(Colors[:dead])
			print(' D ')
		when :close
			print(Colors[:close])
			print(' C ')
		else
			print('   ')
		end

		print(Colors[:reset])

		if prio < -5
			print(Colors[:very_high])
		elsif prio < 0
			print(Colors[:high])
		elsif prio > 5
			print(Colors[:low])
		elsif prio > 0
			print(Colors[:very_low])
		end

		printf('[%3s]', @prio.to_s)

		print(' [')
		case @timetype
		when :none
			print('                   ')
		when :time
			print('           ' + @when.strftime('%T'))
		when :date
			print(@when.strftime('%F') + '         ')
		when :datetime
			print(@when.strftime('%F %T'))
		end
		print(']')
		print(' ' + id_fmt)
		print(' ' + @what)
		print(Colors[:reset])

		puts
	end

	# Show an item's body.
	def show_detail
		print(Colors[:header])
		puts(id_fmt)
		puts(id_fmt.gsub(/./, '-'))
		print(Colors[:reset])
		puts

		puts(@content)

		puts
	end

	# Compatible with legacy "gitodo --raw".
	def show_raw
		print("#{@prio} #{@when.strftime('%F %T %s')} ")
		print("#{@warn} #{@nocron ? '1' : '0'} #{timetype_num} ")
		print("#{@id} #{@what}")

		puts
	end

	# Make Item sortable. Sort by priority, then by deadline.
	def <=>(other)
		[@prio, @when] <=> [other.prio, other.when]
	end
end

def load_all_items
	items = []

	Dir.glob('i*').each do |filename|
		f = File.new(filename, 'r')
		lines = f.readlines()
		f.close()

		item = Item.new

		filename =~ /.*i0*([[:digit:]]+)$/
		item.id = $1
		item.filename = filename

		item.content = lines.join('')

		lines.each do |line|
			if line =~ /^(prio): (.*)/
				item.prio = $2.to_i
			elsif line =~ /^(when|dead): (.*)/
				begin
					# XXX: Hackaround to be able to use DateTime.parse in
					# the local timezone.
					item.when = DateTime.parse($2)
					item.when -= Time.now.utc_offset / 86400.0
					item.when = item.when.to_time
				rescue ArgumentError
					$stderr.puts("#{filename}'s deadline is not a valid date.")
					item.when = Time.now()
				end

				spaces = $2.count(' ')
				colons = $2.count(':')
				case spaces
				when 0
					if colons > 0
						item.timetype = :time
					else
						item.timetype = :date
					end
				else
					item.timetype = :datetime
				end
			elsif line =~ /^(warn): (.*)/
				item.warn = $2.to_i
			elsif line =~ /^(what|subject): (.*)/
				item.what = $2
			elsif line.strip == 'nocron'
				item.nocron = true
			end
		end

		items << item
	end

	return items
end

def check_and_chdir_repo(dir)
	if Dir.exists?(dir + '/.git')
		Dir.chdir(dir)
	end
end

def print_header(indent=false)
	print(Colors[:header])
	puts((indent ? "\t" : '') + ' S Prio        Deadline          ID   Subject')
	puts((indent ? "\t" : '') + ' - ----- --------------------- ------ -------')
	print(Colors[:reset])
end

def list_items(items, indent=false)
	print_header(indent)
	items.sort.each do |i|
		if !i.hide?
			if indent
				print("\t")
			end
			i.show_brief
		end
	end
end

def print_items(items)
	items.each do |i|
		i.show_detail
	end
end

def filter_ids(items, filters_str)
	filters = filters_str.map do |f|
		case f
		when %r{^:/(.*)}
			f = Regexp.new($1, Regexp::IGNORECASE)
			lambda { |i| i.what =~ f }
		when 'dead'
			lambda { |i| i.classify == :dead }
		when 'close'
			lambda { |i| i.classify == :close }
		else
			lambda { |i| i.id == f }
		end
	end
	out = []
	filters.each do |f|
		selected = items.select { |i| f.call(i) }
		selected.sort!
		out.push(*selected)
	end
	return out
end

def filter_bodies(items, filter)
	items.select { |i| i.content =~ /#{filter}/i }
end

def filter_rotting(items, months)
	now = Time.now
	items.select do |i|
		lchange = `git log '--pretty=format:%ct' -n 1 -- "#{i.filename}"`
		lchange = Time.at(lchange.to_i)
		now - lchange > months * 60 * 60 * 24 * 30
	end
end

def print_cron(items, selection)
	outdated = filter_ids(items, ['dead'])
	outdated.select! { |i| !i.nocron }
	if outdated.size > 0
		puts('OUTDATED TASKS:')
		puts('===============')
		puts
		list_items(outdated, true)
	end

	if selection == :all
		close = filter_ids(items, ['close'])
		close.select! { |i| !i.nocron }
		if close.size > 0
			if outdated.size > 0
				puts
				puts
			end

			puts('DEADLINE CLOSE:')
			puts('===============')
			puts
			list_items(close, true)
		end
	end
end

def new_filename()
	filename = 'i' + ('%04d' % rand(0..9999))
	while File.exists? filename
		filename = 'i' + ('%04d' % rand(0..9999))
	end
	return filename
end

def new_items(how_many)
	out = []
	how_many.times do
		out << new_filename()
	end
	out
end

def new_items_from_files(orig_pwd, sources)
	out = []
	orig_pwd_path = Pathname.new(orig_pwd)
	sources.each do |s|
		f = new_filename()
		s_path = Pathname.new(s)
		if s_path.absolute?
			FileUtils.cp(s, f)
		else
			FileUtils.cp(orig_pwd_path + s, f)
		end
		out << f
	end
	out
end

def edit(editor, edit_single, filenames)
	if filenames.size == 0
		return
	end

	if edit_single
		system "#{editor} #{filenames.join(' ')}"
	else
		filenames.each do |f|
			system "#{editor} #{f}"
		end
	end
end

def delete_items(items)
	items.each do |i|
		File.delete(i.filename)
	end
end

def commit
	system 'git add -A .'
	system 'git commit -m "Auto-Commit by gitodo on $(hostname)"'
end


# Use $HOME/.local/share as a fallback if $XDG_DATA_HOME is not set.
# $GITODO_DATA can override the location anyway. Vim is our default
# editor.
default_prefix = ENV['XDG_DATA_HOME'] || (ENV['HOME'] + '/.local/share')
datadir = ENV['GITODO_DATA'] || (default_prefix + '/gitodo.items')
editor = ENV['GITODO_EDITOR'] || ENV['EDITOR'] || 'vim'
edit_single = ENV['GITODO_EDIT_SINGLE'] || false

# See if the repo exists and cd to it. We need to chdir for commit() to
# work.
orig_pwd = Dir.pwd()
if !check_and_chdir_repo(datadir)
	$stderr.puts "`#{datadir}' is not a Git repository."
	exit 1
end

items = load_all_items

if ARGV.size == 0
	list_items(items)
	exit
end

# Options may be given as "--foo", "-foo" or "foo".
opt = ARGV[0].sub(/^-+/, '')
ARGV.shift

case opt
when 'new', 'n'
	edit(editor, edit_single, new_items(ARGV[0] ? ARGV[0].to_i : 1))
	commit
when 'new-from-files', 'f'
	edit(editor, edit_single, new_items_from_files(orig_pwd, ARGV))
	commit
when 'list', 'l'
	list_items(filter_ids(items, ARGV))
when 'print', 'p'
	print_items(filter_ids(items, ARGV))
when 'body', 'b'
	print_items(filter_bodies(items, ARGV[0]))
when 'edit', 'e'
	edit(editor, edit_single, filter_ids(items, ARGV).map { |i| i.filename })
	commit
when 'delete', 'd'
	filter_ids(items, ARGV).each do |i|
		puts "Deleting #{i.id_fmt}: #{i.what}"
		File.delete(i.filename)
	end
	commit
when 'count'
	total = items.size
	dead = items.count { |i| i.classify == :dead }
	close = items.count { |i| i.classify == :close }
	puts("#{dead} #{close} #{total}")
when 'cron', 'c'
	print_cron(items, :all)
when 'cron-outdated', 'o'
	print_cron(items, :no_close)
when 'raw'
	items.each { |i| i.show_raw }
when 'rotting'
	list_items(filter_rotting(items, ARGV[0] ? ARGV[0].to_i : 3))
else
	puts 'gitodo: Invalid option. See manpage.'
end
