#!/bin/bash

# ------------------------------------------------------------------
# "THE PIZZA-WARE LICENSE" (Revision 42):
# Peter Hofmann <pcode@uninformativ.de> wrote this file. As long as you
# retain this notice you can do whatever you want with this stuff. If
# we meet some day, and you think this stuff is worth it, you can buy
# me a pizza in return.
# ------------------------------------------------------------------


# Defaults and "configuration".
EDITOR=${EDITOR:-vim}
itemsbase=${XDG_DATA_HOME:-"$(dirname "$0")"}
itemsdir="$itemsbase/gitodo.items"

# These are essential.
shopt -s nullglob
shopt -u dotglob

# Only use tput if it's available and if stdout is a terminal. Usage of
# color may be enforced, though. Do this check only once -- afterwards,
# __tput may be used as a wrapper for tput.
if which tput >/dev/null 2>&1
then
	if [[ -t 1 ]] || [[ -n $GITODO_FORCE_COLOR ]]
	then
		use_tput=1
	fi
fi

__tput()
{
	[[ -n $use_tput ]] && tput "$@"
}

header()
{
	# Header.
	__tput bold
	echo 'O Prio        Deadline          ID   Subject'
	echo '- ----- --------------------- ------ -------'
	__tput sgr0
}

read_items_raw()
{
	# Process all item files and extract relevant fields.
	for i in i*
	do
		# Read the file and ensure compatibility with "broken" files.
		item=$(< "$i")
		item=${item//$'\r'/}

		# Process the file line by line and read header fields. Do word
		# splitting but don't do globbing.
		set -o noglob

		OIFS=$IFS
		IFS=$'\n'
		lines=($item)
		IFS=$OIFS

		prio=0
		when=""
		warn=1
		subject=""
		nocron=0

		for line in "${lines[@]}"
		do
			set -- $line
			case $1 in
				prio:)
					prio=$2
					;;
				when:|dead:)
					shift
					when=$@
					;;
				warn:)
					warn=$2
					;;
				what:|subject:)
					shift
					subject=$@
					;;
			esac

			# Exclude this item from cron warnings?
			[[ "$line" == "nocron" ]] && nocron=1
		done

		set +o noglob

		# Normalize deadline.
		whennorm=$(date -d "$when" '+%F %T')

		# Find out whether it's date + time, only date or only time.
		spaces=${when//[^ ]/}
		spaces=${#spaces}
		colons=${when//[^:]/}
		colons=${#colons}

		case $spaces in
			0)
				if (( colons > 0 ))
				then
					# Only time.
					timetype=0
				else
					# Only date.
					timetype=1
				fi
				;;
			*)
				# Date + time or something like "next tuesday 8am".
				timetype=2
				;;
		esac

		if [[ "$when" == "" ]]
		then
			# No date or time.
			timetype=3
			whennorm='2038-01-01 00:00:00'
		fi

		# Get the ID by removing the "i" and leading zeros from the
		# filename. Usage of expr is a nice trick: It doesn't recognize
		# octal numbers and doesn't output leading zeros. Hence, adding
		# 0 effectively strips leading zeros.
		id=${i//i/}
		id=$(expr "$id" + 0)

		# Print these infos so they can be sorted. Then read them again.
		echo "$prio $whennorm $warn $nocron $timetype $id $subject"
	done |
	sort -n
}

pretty_print_items()
{
	while read -r prio day time warn nocron timetype id subject
	do
		# Pretty printing. This function is meant to be fed the output
		# of read_items_raw().

		# Find out if the deadline has passed.
		stampitem=$(date -d "$day $time" '+%s')
		taskdiff=$((stampnow - stampitem))
		if ! (( cron & nocron )) && (( timetype != 3 ))
		then
			if (( taskdiff > 0 ))
			then
				__tput bold
				__tput setaf 1
				echo -n '! '
				__tput sgr0
			elif (( taskdiff > -warn * 3600 ))
			then
				__tput setaf 1
				echo -n '* '
				__tput sgr0
			else
				echo -n '  '
			fi
		else
			echo -n '  '
		fi

		# Highlight according to priority.
		if (( prio < -5 ))
		then
			__tput bold
			__tput setaf 1
		elif (( prio < 0 ))
		then
			__tput setaf 1
		elif (( prio > 5 ))
		then
			__tput setaf 4
		elif (( prio > 0 ))
		then
			__tput setaf 2
		fi
		printf '[%3s] ' "$prio"

		# Show only those time fields that are set in the item's file.
		case $timetype in
			0) echo -n "[           $time]" ;;
			1) echo -n "[$day         ]" ;;
			2) echo -n "[$day $time]" ;;
			3) echo -n "[                   ]" ;;
		esac

		# ID and subject.
		printf ' [%4d] ' "$id"
		echo "$subject"

		__tput sgr0
	done
}

list_items()
{
	# List all items.

	# Is this output meant for cronjobs?
	[[ $1 == cron ]] && cron=1 || cron=0

	# Get the current timestamp.
	stampnow=$(date '+%s')

	read_items_raw | pretty_print_items
}

count_tasks()
{
	# Count outdated tasks, those whose deadline is close and all tasks
	# in total.

	out=$(use_tput= list_items)
	outdated=$(echo "$out" | grep '^!' | wc -l)
	warning=$(echo "$out" | grep '^\*' | wc -l)
	echo $outdated $warning $(echo "$out" | wc -l)
}

cron_output()
{
	# Show outdated tasks and those whose deadline is close.

	# Find relevant tasks.
	out=$(use_tput= list_items cron)
	outdated=$(echo "$out" | grep '^!')
	warning=$(echo "$out" | grep '^\*')

	# Pretty printing.
	if [[ "$outdated" != "" ]]
	then
		echo 'OUTDATED TASKS:'
		echo '==============='
		echo
		(
			header
			echo "$outdated"
		) | sed 's/^/    /'

		if [[ "$warning" != "" ]]
		then
			echo
			echo
		fi
	fi
	if [[ "$warning" != "" ]] && [[ $1 == 1 ]]
	then
		echo 'DEADLINE CLOSE:'
		echo '==============='
		echo
		(
			header
			echo "$warning"
		) | sed 's/^/    /'
	fi
}

new_items()
{
	# Create $1 new items.

	for (( i = 0; i < $1; i++ ))
	do
		# Get a random free ID. This is done in order to reduce the
		# possibility of conflicts. Imagine you add a new item on
		# computer A and (in parallel) a new item on computer B. When
		# merging the two branches, you'd get a conflict.

		next=$((RANDOM % 9999))
		while [[ -f "$(complete_id $next)" ]]
		do
			next=$((RANDOM % 9999))
		done

		$EDITOR "$(complete_id $next)"
	done
}

complete_id()
{
	# Complete an ID (like "03") by properly padding it and by adding
	# the "i" (result: "i0003").

	printf 'i%04d' $(expr $1 + 0)
}

checkrepo()
{
	# Initialize the repo (if needed) and cd to it.

	mkdir -p "$itemsdir"
	cd "$itemsdir"
	[[ -d .git ]] || git init
}

commit()
{
	# Commit all changes in the repo.

	git add .
	git commit -a -m "Auto-commit $HOSTNAME."
}

checkrepo

if [[ -z "$1" ]]
then
	header
	list_items
	exit
fi

case "$1" in
	--edit|-edit|edit|--e|-e|e)
		shift
		for i
		do
			$EDITOR "$(complete_id "$i")"
		done
		commit
		;;
	--print|-print|print|--p|-p|p)
		shift
		for i
		do
			cat "$(complete_id "$i")"
			echo
		done
		;;
	--new|-new|new|--n|-n|n)
		new_items "${2:-1}"
		commit
		;;
	--delete|-delete|delete|--d|-d|d)
		shift
		for i
		do
			rm -v "$(complete_id "$i")"
		done
		commit
		;;
	--log|-log|log|--l|-l|l)
		shift
		git log --oneline --decorate --graph "$@"
		;;
	--cron|-cron|cron|--c|-c|c)
		cron_output 1
		;;
	--cron-outdated|-cron-outdated|cron-outdated|--o|-o|o)
		cron_output 0
		;;
	--count|-count|count)
		count_tasks
		;;
	--raw)
		read_items_raw
		;;
	*)
		cat <<EOM
Usage: $(basename "$0") [options]...

  -e, --edit id [id...],     Edit all given IDs using \$EDITOR.
  -p, --print id [id...]     Dump all given IDs to stdout.
  -n, --new [n]              Add a new task. You'll be put in your
                             \$EDITOR to do so. If you specify 'n',
                             then 'n' new tasks will be created.
                             ('n' defaults to 1).
  -d, --delete id [id...]    Delete all given IDs.
  -l, --log [options]        Show log of the items repository. Add
                             options to "git log" if desired.
  -c, --cron                 Show a list of outdated tasks and tasks
                             close to the deadline, suitable for a cron
                             job.
  -o, --cron-outdated        Show a list of outdated tasks, suitable for
                             a cron job.
  --count                    Count tasks (all open tasks, tasks close to
                             deadline and outdated tasks).
  --raw                      Don't do pretty printing. This option is
                             meant for scripting.
  -h, --help                 Show this help page.

  If no options are given, a list of all TODO items is shown.
EOM
		;;
esac
